[[модель ии]] анализирует [[данные]] и строит общую зависимость. Но вместо того, чтобы выводить формулу, мы научимся распределять объекты по классам.
![[Pasted image 20250818182748.png]]
Но сегодня мы будем работать не с животными, а с **ирисами** — одним из классических открытых [[датасет]]ов.![[Pasted image 20250818182817.png]]
В датасете есть три вида ирисов: они называются Setosa, Versicolor и Virginica. Но для простоты мы возьмем только два из них: Versicolor и Virginica. В качестве данных о цветках можно брать размеры их лепестков (petal) или чашелистиков (sepal): они отличаются для разных видов!

Наша первая модель будет работать с длиной лепестков (параметр `petal length`) и их шириной ([[параметр]] `petal width`).
Цель модели — научиться по длине и ширине лепестка определять класс (вид) цветка.
![[Pasted image 20250818183155.png]]
В обучении нашей модели нужны будут примеры данных: размеры лепестков и виды конкретных цветов. Для этого мы скормим ей учебный датасет `iris`. Отдельно скачивать его не надо, он входит в библиотеку [[sklearn]].

Посмотрим, как он выглядит: ([[Pandas]], [[DataFrame (датафрейм)]])
```python
# подключаем библиотеки
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris # функция load_iris загружает учебный датасет

# загружаем датасет
iris = load_iris()

# создаем датафрейм на основе данных о цветках
df = pd.DataFrame(data=iris.data, columns=iris.feature_names)

# добавляем новую колонку species (вид) с классом цветка (0 для Setosa, 1 для Versicolor, 2 для Virginica)
df['species'] = iris.target

# печатаем первые несколько строк датафрейма
print(df.head())
```
Программа выведет такую таблицу:
![[Pasted image 20250818183625.png]]
Мы уже решили использовать только два признака: длину и ширину лепестка, и только два класса: 1 (Versicolor) и 2 (Virginica). Удалим из таблицы лишнее:
```python
# удаляем все цветки Setosa
df = df[df['species'] != 0]  

# создаем отдельную табличку с признаками цветков
X = df[['petal length (cm)', 'petal width (cm)']]

# создаем отдельную табличку с классами цветков
y = df['species']
```
По итогу мы получили датафрейм `X` с входными данными ([[входные данные]], параметрами лепестка) и датафрейм `y` с выходными данными ([[выходные данные]]классом цветка).
Наша модель должна находить общую зависимость между X и y.
Посмотрим на данные на графике: ([[Matplotlib]])
```python
# подключаем библиотеку
import matplotlib.pyplot as plt

# создаем точечную диаграмму
# координаты точек — это длина и ширина лепестков
# цвет точек — это класс ириса
plt.scatter(X['petal length (cm)'], X['petal width (cm)'], c=y, cmap='viridis')

# оформляем график
plt.xlabel('Длина лепестка'), plt.ylabel('Ширина лепестка')
plt.title('Распределение видов Iris')

# добавляем легенду для цветов
plt.colorbar(ticks=[1, 2], label='Класс (1=Versicolor, 2=Virginica)')

# показываем график
plt.show()
```
![[Pasted image 20250818184236.png]]

Точки на графике — это данные о цветках, на которых модель обучается. Но предсказывать результат она должна для **любого цветка**. То есть, наша задача превращается в такую:

Для каждой точки поля (данных о лепестке цветка) определить ее цвет (класс цветка).

По сути, модель классификации смотрит на поле, где есть несколько цветных точек, и по ним решает, как раскрасить все остальное.

Как обучить такую [[модель ии]]?
Мы уже встречались с задачей **линейной регрессии**([[Предсказание линейных зависимостей]]). Там мы создавали функцию (прямую([[прямая]]), проведенную через точки) и улучшали ее, уменьшая функцию ошибки.

В этой задаче прямая `y = kx + b` не подойдет — в качестве входных данных у нас не одно число x, а два!

Но можно применить тот же подход: выбрать примерную функцию, а потом менять ее параметры так, чтобы ошибка стала минимальной. Наша модель будет называться **логистической регрессией**([[логистическая регрессия]]).