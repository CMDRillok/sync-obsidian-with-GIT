Как и зачем использовать все эти операции?

Одно из самых очевидных и полезных применений матриц — это **решение систем линейных уравнений([[система уравнений]])**.

Берем систему линейных уравнений:
![](https://yastatic.net/s3/lyceum/files/11b0c2c7-beae-4f16-a1b2-033527e97066/upload.png)

Понимаем, что то же самое можно записать с помощью [[вектор]]ов:
![](https://yastatic.net/s3/lyceum/files/30db1d9d-ffc0-43d5-9b0c-77cdf1737d1d/upload.png)

Ведь если в таком выражении векторы умножить на скаляры x, y и z, а потом сложить — получится ровно наша система уравнений!
Но если воспринять (x, y, z) как вектор, то выражение слева превращается...
![](https://yastatic.net/s3/lyceum/files/d9e3c69e-c6b3-4f7e-9497-fc452cf66891/upload.png)

...в произведение матрицы([[матрицы в python]]) на вектор!
А значит, все [[уравнение]] можно записать так:
![](https://yastatic.net/s3/lyceum/files/8f4710ee-0900-4060-b388-be6be36db757/upload.png)

И вот уже задача «решить систему уравнений» превращается в задачу «решить одно уравнение», которую мы уже умеем выполнять — с помощью поиска обратной матрицы!
В библиотеке numpy есть специальная функция для решения уравнений вида **Ax = b**: `np.linalg.solve(A, b)`.

```python
# создаем матрицу
A = np.array([[1, 4, -1],
              [-1, -3, 2],
              [2, -1, -2]])

# создаем вектор правой части уравнения
b = np.array([-1, 2, -2])

# решаем уравнение
result = np.linalg.solve(A,b)
print(result) # напечатает [0. 0. 1.]
```
