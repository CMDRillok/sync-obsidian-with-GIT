
[[матрицы в python]] можно складывать, умножать на число, [[вектор]] или другую матрицу. Сейчас разберем, как именно!
### Сложение матриц
Сложение матриц, как и [[Сложение векторов]], суммирует каждый элемент первой матрицы с соответствующим элементом второй.
**Складывать можно только матрицы одной формы!**
![[Pasted image 20250731141519.webp]]
```python
import numpy as np

A = np.array([[2, 3],
              [4, 5]])
B = np.array([[1, 1],
              [2, 2]])
C = A + B

print(C)
```
```python
# или можно использовать метод .add() из библиотеки np
C2 = np.add(A, B)
print(C2) # выведет то же самое
```

```output
[[3 4]
 [6 7]]
```
### Умножение на число

При умножении матрицы на число все ее элементы умножаются на это число.
```python
matrix = np.array([[1, 2], 
                   [3, 4], 
                   [5, 6]])

matrix_result = matrix * 2

print(matrix_result)
```

```Output
[[ 2  4]
 [ 6  8]
 [10 12]]
```

### Умножение матрицы на вектор
При умножении матрицы A на [[вектор]] x вычисляется скалярное произведение между вектором и всеми строками матрицы. Получившиеся m чисел — это новый вектор.
Представь себе, что вектор поворачивают горизонтально и кладут по очереди на каждую строку матрицы, вычисляя скалярное произведение. Эти скалярные произведения собираются в новый вектор!
Матрицу формы m × n можно умножить только на вектор размера n. В итоге получится вектор размера m.
![[Pasted image 20250731141944.webp]]

### Перемножение матриц
Умножение матриц — это продвинутая версия умножения матрицы на вектор.

Посмотри на пример. Для перемножения матриц мы каждый столбец правой матрицы умножаем на левую матрицу, как вектор. Полученные два вектора — это столбцы новой матрицы.

Чтобы матрицы можно было перемножить, количество строк правой матрицы должно быть равно количеству столбцов левой.

При умножении матрицы формы m × n на матрицу формы n × k получается матрица формы m × k.

Значит, две квадратные матрицы можно умножать в любом порядке. Но результат получится разный! Перемена мест множителей приведет только к страданию — так что записывай в коде умножение матриц с аккуратностью.

```python
import numpy as np

# создаем две матрицы
matrix_A = np.array([[1, 2], 
                     [3, 4]])
matrix_B = np.array([[5, 6], 
                     [7, 8]])

# умножаем матриц с использованием np.matmul()
result1 = np.matmul(matrix_A, matrix_B)
print(result1)

# умножаем матриц с использованием оператора @
result2 = matrix_A @ matrix_B
print(result2) # выведет то же самое
```

```Output
[[19 22]
 [43 50]]
```

### [[Транспонирование]] матрицы
Транспонирование матрицы отражает матрицу по диагонали.
![[Pasted image 20250731142237.webp|589]]
Такое преобразование меняет местами строки и столбцы: элемент с индексами (i, j) окажется на месте (j, i).

В математике транспонирование записывается с помощью верхнего индекса T.
В коде ты можешь получить транспонированную матрицу с помощью атрибута `.T`:
```python
import numpy as np

# создаем матрицу
matrix = np.array([[1, 2, 3],
                   [4, 5, 6]])

transposed_matrix = matrix.T  # транспонирование матрицы

print(matrix)
# выведет:
# [[1 2 3]
#  [4 5 6]]

print(transposed_matrix)
```

```Output
[[1 4]
 [2 5]
 [3 6]]
```
### Вычисление обратной матрицы

Возьмем матрицу `A`. Матрица, обратная к `A` — это такая матрица `A⁻¹`, которая при умножении на `A` даст единичную матрицу:
![[Pasted image 20250731142457.webp]]
**Не у всех матриц есть [[обратная матрица]]!**
Матрицы, у которых нет обратных матриц, называются сингулярными (вырожденными).

Обратную матрицу для квадратной матрицы (если она существует) можно вычислить с помощью функции `np.linalg.inv()`.

```python
import numpy as np

# создаем матрицу
A = np.array([[2, 3],
              [1, 4]])

# вычисляем обратную матрицу
A_inv = np.linalg.inv(A)

print(A_inv)
```

```Output
[[0.8 -0.6]
 [-0.2  0.4]]
```
